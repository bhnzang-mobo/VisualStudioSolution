#문제
	원판이 있다.
	원판위에 숫자가 있다.
	숫자들의 인접한 정보가 주어진다.
	원판을 반시계 방향으로 돌리거나,
	시계 방향으로 돌리는 방법을 구현해야한다

	인접한 수가 같은지 다른지 구해야한다.
	
	판 위에 있는 수들이 서로 같은지 구해야한다.(같으면 지워야해서)
	판에 남은 숫자들은 

#회전
	양 끝에 버퍼를 남겨 비교할 수 있도록 구조를 설계함

#같은수 찾기 BFS();
	바깥쪽에서 안쪽으로 진행한다.
	안쪽에서 바깥쪽 원소에 대해 검사할 필요는 없다.
	만약 지울 수 있다면 이미 바깥에서 가능했기 때문.
	단, 맨 안쪽은 원판은 더 안쪽에 비교할 원소가 없기 때문에
	원판 자기 자신만 검사하도록 한다.

	인접한 수중에 자기 자신을 지우고 나면 맨 마지막에
	x,y에서 인접한 것들중 x,y와 같은게 있으면 enqueue
	
	지우기
	평균 이상 이하 더하고 뺴기
	총 2500개의 수
	N<=50 M<=50
	T<=50
	다른 BFS, 로테이션, 자료구조는 매우 완벽했다.
	다만 아래 두가지.
	
	오답 유발
	세가지 방향만 고려했다.(옆, 아래)
	아래쪽을 고려하면 당연히 위도 고려되는거 아닌가? 했지만
	BFS하면서 루프 안에서, 옆으로 진행한 뒤 위로 올라가는 경우도 있다.


	메모리 초과 유발
	BFS할땐 항.상. 방문 체크를 해야한다
	BFS해서 어떤 노드를 방문하고자 할때
	최소한 그 노드와 관련한 정보 하나가 바뀌어야 한다
	그렇지 않으면 다른곳에서 동시에,여러번 방문하고자한다.
	BFS를 쓸땐 꼭 체크를해야한다.
